* java并发
  * 什么是进程和线程
    
    进程：程序的开始到关闭的过程就是一个进程，所以我们可以用进程来造句：这个进程开了很久（这个程序还没关），任务管理器的这个进程在哪（找它的PID，程序编号/进程编号）

    线程：一个进程有main主线程和其他线程构成，线程共享进程的堆和方法区，却又有独自的程序计数器（指向指定地址），虚拟机栈（java方法的局部变量）和本地方法栈（本地方法的局部变量，本地方法的意思却是调用C语言，可能本地指在不懂地调用非java语言吧）。
   * 线程的转换
   
     启动》可执行》因为其他线程用了锁而阻塞/睡眠等待/挂起等待（被罚站一样，要么惩罚执行完，要么等老师通知）》terminate完毕
     
  * 进程和线程的关系，区别和优缺点
  
    一个进程有多个线程，线程是进程的更小执行单元。区别是原来线程会相互影响，因为共用了堆的对象和方法区的一些变量；进程是独立，进程会可能会共享同一个外部资源，但不会分享自己的内部资源，所以不会互相影响。因此优缺点很明显：进程的资源安全问题更好，适合管理隔离一些资源；而线程有切换速度开，开销小的特点。
    
  * 并发和并行
    
    并行是同一时间点做任务，与CPU内核数一样；并发是同一时间段多任务，与线程数一样。
    所以项目开发追求高并发而不是高并行，就是因为并行处理任务数量被物理条件内核限制住了，处理不了海量请求。
    
  * 什么是上下文切换
    
    线程间按照时间片轮转的切换就是上下文切换，linux系统切换开销小，怪不得在虚拟机上搭建集群。
    
   * 什么是死锁，如何避免
   
     通俗讲，死锁就是多个线程共享资源，对资源上锁，又不会因为后来的请求而释放，忙则等待，所以一旦出现进程占用了彼此需要的不同资源就会无限期等对方释放，而对方需要他的资源释放才能完成的矛盾。
     避免就是破坏死锁的条件，互斥是不可能的，可以的是一次性申请资源或在申请不到资源就把自己的才释放或以同样的顺序请求资源

   * 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？
   
     因为线程start后不一定就立马run，得等分配到时间片、资源；如果直接调用run，就不是线程了，和普通函数一样了。
     
   * 说说 sleep() 方法和 wait() 方法区别和共同点?
   
      sleep是睡眠等待,wait是挂起等待；sleep在一定时间后会自动唤醒，wait需要被notify或等其他线程执行完；wait适合进程通信，会释放锁，让资源流动，sleep只是简单地暂停。

* java并发进阶
  * synchronized的了解，使用，底层，JDK1.6 之后的底层优化，谈谈 synchronized和ReentrantLock 的区别

     synchronized关键字可以实现多线程的资源加锁，完成同步。

    它的使用分别是修饰类，方法和代码块，相当于给他们上锁，一旦对象实例化，必须拿到相应的锁才能执行方法。锁还分静态和非静态，它们可以是同名，也可以同时使用。双重校验锁实现对象单例（线程安全）

    底层是对于代码块来说，是用监视器的monitorenter开始上锁，moniterexit结束释放；对于类来说使用ACC_SYNCHRONIZED标识符让JVM去识别。

    1.6的优化包括：由于传统的锁是重量级锁，锁的线程是映射到很远的操作系统线程上的，申请互斥量就要跑很远，还需要从用户态转变内核态，这是很耗费时间的。所以当不用申请互斥量，也就是竞争不激烈时，1.无竞争且只有一个线程可以采用偏向锁（大致作用就是第一个申请的线程使用一次CAS，记录到MarkWord里，以后申请就直接给它锁，不用多次CAS/申请互斥量）2.偏向锁失败？升级为轻量级锁，多次CAS解决申请锁问题3.自旋锁，就是不挂起休息（因为挂起需要跑到操作系统做状态转换），循环地问有没有锁可以用了。

    ReenTrantLock和Synchronized 都是"可重入锁"（同一线程可以多次调用同一锁，像是用了add方法，锁计数器+1；用了同一的类mul方法，计数器再+1；不可重入锁add时候不能mul了），前者是API，后者是JVM；前者的锁对象一个可以有多个“Condition”实例，线程可以放在实例上，这让ReentrantLock可以选择性地加锁，而且notifyAll（）的时候只会唤醒同一个实例上的线程而不是所有实例上的线程。

   * JMM是什么， 说说 synchronized 关键字和 volatile 关键字的区别

     JMM是JAVA内存模型，它是JAVA内存的“访问规范”，也就是怎么访问内存可以更安全，更高效。

     它的访问规范是这样的：主内存存放所有变量，线程有各自的独立工作内存，里面存放的主内存的拷贝变量！问题在于多线程访问，可能一个线程改变了某一变量，但另一线程还在用没更新的拷贝副本变量操作。所以要改变之后立马同步到主内存，用这个变量就去主内存更新变量值，所以volatile就是说明这个变量是同步的，是需要这么做的。

     volatile只能修饰变量，因为使用更新的原理，所以不会阻塞问题；同时它主要是实现变量的可见性，而不能够实现原子性，synchronized则注重资源的同步性。
    
    * 线程的使用
    
      实现Runnable重写run方法或实现Callable重写call方法（可以有返回值），但他们都是“任务”,不算线程，反倒像线程里的run，所以终归是需要Thread.start(参数)，参数是Runnbale对象或者Callable用FutureTask封装的对象。
    
     再或者继承Thread，Java是单继承，多接口，所以上面两种方法虽然像是run，Thread自己也可以，但是价值就在这里。
    
    * ThreadLocal是什么
    
      ThreadLocal就是申明，我想改这个变量但不想同步到主内存里，像是日期格式，这样每个线程可以有自己设计的格式。底层原理是ThreadLocal其实是ThreadLocalMap的封装类，这个map,key是本地线程对象（弱引用），value是你赋的值（强引用，得用方法变成弱引用才能GC）
    
    * 为什么要用线程池
     
      将线程集中在线程池可以统一管理、监控，也可以限制线程数，而且它更像Redis的缓存，可以重复利用，所以降低线程重复创建和销毁的能耗，与此同时提高已有线程调用的响应速度。
    
    * JUC 包中的原子类是哪4类?好处是什么?
      
      JUC就是java.util.concurrent，并发包；其实它的原子类的作用是用它定义的原子类去包装你的数据，然后你用它封装的方法操作（以原子的方式去更新数据），所以好处就是你不用去给方法声明synchronized，就可以实现资源共享（感觉像volatile封装成各个原子类名，还加了方法）；
      既然是以原子的方式去更新数据，就有4种数据类型：基本数据类型（AtomicInteger/Long/Boolean）,数组类型(AtomicInteger/Long/ReferenceArray),引用类型（AtomicReference/StampedReference/MarkableRefernce）,对象的属性修改类型（AtomicLongField/IntegerFieldUpdater,AtomicStampedReference）
      
    * 能不能给我简单介绍一下 AtomicInteger 类的原理
    
      用本地方法unsafe的objectFieldOffset获得旧值的地址，采用cas去置换，保存到volatile变量去可见。
    
    * AQS是什么，AQS 原理是什么，AQS定义两种资源共享方式，AQS底层使用了模板方法模式
    
      AQS是锁和同步器的框架，很多锁（ReentrantLock,Semophoe等）都是在这个框架的基础上搭建的，也就是重写AQS的方法。
      
      原理有点搞笑，以为是怎怎么么同步，到头来只是管理线程阻塞如何排队和唤醒（但这确实就是锁的雏形啊），还以为是怀着特警的梦想去当了交警。
      
      用了双向的虚拟队列去访问资源，去节点建立联系。
      
      资源分为独占（单线程锁ReentrantLock）和分享（多线程锁CountDownLatch）
      
      模板方法模式就是继承AbstractQueuedSynchronizer，去重写它的方法。
      
      值得一提的模板方法就那几个：判断是否独占资源（isHeldExclusively），抢占/释放资源(tryAcquire/Release,共享方式的：tryAcquireShared,tryReleaseShared.
      
    
    
    
    
