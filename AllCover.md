* java并发
  * 什么是进程和线程
    
    进程：程序的开始到关闭的过程就是一个进程，所以我们可以用进程来造句：这个进程开了很久（这个程序还没关），任务管理器的这个进程在哪（找它的PID，程序编号/进程编号）

    线程：一个进程有main主线程和其他线程构成，线程共享进程的堆和方法区，却又有独自的程序计数器（指向指定地址），虚拟机栈（java方法的局部变量）和本地方法栈（本地方法的局部变量，本地方法的意思却是调用C语言，可能本地指在不懂地调用非java语言吧）。
   * 线程的转换
   
     启动》可执行》因为其他线程用了锁而阻塞/睡眠等待/挂起等待（被罚站一样，要么惩罚执行完，要么等老师通知）》terminate完毕
     
  * 进程和线程的关系，区别和优缺点
  
    一个进程有多个线程，线程是进程的更小执行单元。区别是原来线程会相互影响，因为共用了堆的对象和方法区的一些变量；进程是独立，进程会可能会共享同一个外部资源，但不会分享自己的内部资源，所以不会互相影响。因此优缺点很明显：进程的资源安全问题更好，适合管理隔离一些资源；而线程有切换速度开，开销小的特点。
    
  * 并发和并行
    
    并行是同一时间点做任务，与CPU内核数一样；并发是同一时间段多任务，与线程数一样。
    所以项目开发追求高并发而不是高并行，就是因为并行处理任务数量被物理条件内核限制住了，处理不了海量请求。
    
  * 什么是上下文切换
    
    线程间按照时间片轮转的切换就是上下文切换，linux系统切换开销小，怪不得在虚拟机上搭建集群。
    
   * 什么是死锁，如何避免
   
     通俗讲，死锁就是多个线程共享资源，对资源上锁，又不会因为后来的请求而释放，忙则等待，所以一旦出现进程占用了彼此需要的不同资源就会无限期等对方释放，而对方需要他的资源释放才能完成的矛盾。
     避免就是破坏死锁的条件，互斥是不可能的，可以的是一次性申请资源或在申请不到资源就把自己的才释放或以同样的顺序请求资源

   * 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？
   
     因为线程start后不一定就立马run，得等分配到时间片、资源；如果直接调用run，就不是线程了，和普通函数一样了。
     
   * 说说 sleep() 方法和 wait() 方法区别和共同点?
   
      sleep是睡眠等待,wait是挂起等待；sleep在一定时间后会自动唤醒，wait需要被notify或等其他线程执行完；wait适合进程通信，会释放锁，让资源流动，sleep只是简单地暂停。

* java并发进阶
 * synchronized的了解，使用，底层，JDK1.6 之后的底层优化，谈谈 synchronized和ReentrantLock 的区别
 
    synchronized关键字可以实现多线程的资源加锁，完成同步。
   
   它的使用分别是修饰类，方法和代码块，相当于给他们上锁，一旦对象实例化，必须拿到相应的锁才能执行方法。锁还分静态和非静态，它们可以是同名，也可以同时使用。双重校验锁实现对象单例（线程安全）
   
   底层是对于代码块来说，是用监视器的monitorenter开始上锁，moniterexit结束释放；对于类来说使用ACC_SYNCHRONIZED标识符让JVM去识别。
   
   1.6的优化包括：由于传统的锁是重量级锁，锁的线程是映射到很远的操作系统线程上的，申请互斥量就要跑很远，还需要从用户态转变内核态，这是很耗费时间的。所以当不用申请互斥量，也就是竞争不激烈时，1.无竞争且只有一个线程可以采用偏向锁（大致作用就是第一个申请的线程使用一次CAS，记录到MarkWord里，以后申请就直接给它锁，不用多次CAS/申请互斥量）2.偏向锁失败？升级为轻量级锁，多次CAS解决申请锁问题3.自旋锁，就是不挂起休息（因为挂起需要跑到操作系统做状态转换），循环地问有没有锁可以用了。
   
   ReenTrantLock和Synchronized 都是"可重入锁"（同一线程可以多次调用同一锁，像是用了add方法，锁计数器+1；用了同一的类mul方法，计数器再+1；不可重入锁add时候不能mul了），前者是API，后者是JVM；前者的锁对象一个可以有多个“Condition”实例，线程可以放在实例上，这让ReentrantLock可以选择性地加锁，而且notifyAll（）的时候只会唤醒同一个实例上的线程而不是所有实例上的线程。
    
    
    
    
    
    
    
    
    
    
